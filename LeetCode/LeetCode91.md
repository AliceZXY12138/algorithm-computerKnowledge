#### [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)



# 题目描述

一条包含字母 `A-Z` 的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

给定一个只包含数字的**非空**字符串，请计算解码方法的总数。



# 示例

```
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
```

```
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```



# 题解

采用动态规划的解法，经过分析可知，一般情况下，如果当前数和它前面数组合起来是有效的（符合编码），那么dp[i]=dp[i-1]+dp[i-2]，否则，dp[i]=dp[i-1]，这是一般情况下，存在一些特殊情况，比如if(i<2)那么dp[i-2]不存在，此时dp[i]=dp[i-1]+1;再比如，遇到0的情况，具体分析可看代码



# 代码

```c++
//c++
//执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户
//内存消耗：6.2 MB, 在所有 C++ 提交中击败了60.52%的用户

class Solution {
public:
    int numDecodings(string s) {
        int n=s.size();
        vector<int> dp(n,0);
        int x=s[0]-'0';
        if(x>0&&x<=26)
            dp[0]=1;
        //如果第一个数就不满足，直接return 0
        else return 0;
        for(int i=1;i<n;++i){
            int x=s[i]-'0';
            int y=s[i-1]-'0';
            //如果当前值为0，那么0与它前面的值组成的数字必须有效，否则直接return 0
            if(x==0){
                if(y*10>0&&y*10<=26){
                    if(i>1)
                        dp[i]=dp[i-2];
                   	//如果i<=1,那么dp[i-2]越界
                    else
                        dp[i]=1;
                }
                else
                    return 0;
            }
            else if(x>0&&x<=26){
                dp[i]=dp[i-1];
                //这里要注意y（前一个数）不能为0，否则会多算一次
                if(y!=0&&(y*10+x>0)&&(y*10+x<=26))
                    if(i>1)
                        dp[i]=dp[i-1]+dp[i-2];
                	//如果i<=1,那么dp[i-2]越界
                    else
                        dp[i]=dp[i-1]+1;
            }
        }
        return dp[n-1];
    }
};
```

